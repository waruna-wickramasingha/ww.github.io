<!DOCTYPE HTML>
<!--
	This Website was created by Waruna Wickramasingha and it is based on modification and customization of:
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Code Notes</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="/assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
		<div id="wrapper">
			<!-- Main -->
			<div id="main">
				<div class="inner">
					<!-- Header -->
					<header id="header">
						<a href="index.html" class="logo"><strong>Code Notes</strong> by Waruna Wickramasingha</a>
						<ul class="icons">
							<li><a href="https://www.linkedin.com/in/waruna-priyankara-wickramasingha/" class="icon brands fa-linkedin"><span class="label">Medium</span></a></li>
						</ul>
					</header>
					
					<article class="post">
  <h1>What is Python's lru_cache and when to use it?</h1>
  <p class="meta">January 28, 2026</p>
  <p>Have you ever come across scenarios where your Python code is <strong>repeatedly</strong> calling functions that return values which are completely determined by its <strong>input</strong> parameters?</p>

<p>If such functions are light weight - i.e. they only do very simple calculations, we don’t have to worry too much about them. But what if there is a frequently called function doing some heavy and <strong>deterministic</strong>(meaning, its output is completely determined by input parameters) calculations?</p>

<p>Well, Python has a nice little(yet powerful) <strong>built in function decorator</strong> that you can easily use in your code without having to install any additional dependencies. And its thread safe as well!</p>

<h2 id="from-functools-import-lru_cache--to-the-rescue">from functools import lru_cache — to the rescue!</h2>

<p><strong>lru_cache</strong> is one of Python’s most useful decorators for performance optimizations. With correct knowledge on how to use it, <strong>lru_cache</strong> would greatly speedup your code!</p>

<p>However, there are some considerations you need to make sure before start using it. In this article I am going to walk you through when and how to use <strong>lru_cache</strong> and also when not to use it with examples. By the end of reading this post, you would be confident using it to optimize your python code.</p>

<h3 id="the-api"><a href="https://docs.python.org/3/library/functools.html#functools.lru_cache">The API</a></h3>

<p><code class="language-plaintext highlighter-rouge">@functools.lru_cache(maxsize=128, typed=False)</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">maxsize</code> - The maximum number of recent calls to save in the cache. Default is 128 and when <code class="language-plaintext highlighter-rouge">maxsize</code> is set to <code class="language-plaintext highlighter-rouge">None</code>, the LRU feature is disabled and the cache can grow indefinitely without a bound.</li>
  <li><code class="language-plaintext highlighter-rouge">typed</code> - Default is <strong>False</strong>. This determines whether to cache function arguements with different types seperately. (ex: when typed=True, input parameter 3.0 and 3 are considered different resulting in two cache items)</li>
</ul>

<h3 id="lru--least-recently-used">LRU = Least Recently Used</h3>

<p><strong>lru_cache</strong> is a function that <strong>caches</strong>(also known as <strong>memoizes</strong>) function <strong>results</strong> along with their <strong>input parameters</strong>. Under the hood, it is a dictionary that stores</p>
<ul>
  <li>Key: function arguements as a tuple</li>
  <li>Value: function result</li>
</ul>

<p>Sounds simple right?</p>

<p>So where the <strong>least recently used</strong> part come from? 
Well, as everything else, this <code class="language-plaintext highlighter-rouge">cache</code> also can have a size that we can define at declaration using <code class="language-plaintext highlighter-rouge">maxsize</code> parameter(we can also have unlimited cache size by setting <code class="language-plaintext highlighter-rouge">maxsize=None</code> as well). However, when the cache is full, it removes the <strong>least recently used items</strong> from it and hence it is called a <strong>least recently used(LRU)</strong> cache.</p>

<h3 id="the-problem-of-expensive-repeated-calculations">The problem of Expensive Repeated Calculations</h3>

<p>Take a look at the following example when calculating the <a href="https://en.wikipedia.org/wiki/Fibonacci_sequence">Fibbonacci sequence</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="s">"""Calculate nth Fibonacci number - SLOW!"""</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Computing fib(</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">)"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>Now if I called <code class="language-plaintext highlighter-rouge">result = fibonacci(10)</code> it will be painfully slow! Because if you look closely, what happens under the hood is,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Computed again!
</span><span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Computed again!
</span><span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Computed again!
</span><span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Computed again!
</span><span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># Computed again!
</span><span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Computed again!
</span><span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Computed again!
</span><span class="p">...</span>
</code></pre></div></div>

<p>You would see a lot of repeated calculations are done which is indeed a waste of computing resources. Imagine calling <code class="language-plaintext highlighter-rouge">fibonacci(35)</code> that would make staggering 29 million function calls! Energy bills are quite high nowadays, the same function could have done much better by simply decorating with our hero <strong>lru_cache</strong>!</p>

<h3 id="decorating-with-lru_cache">Decorating with @lru_cache</h3>

<p>In the below code, nothing has changed except decorating the same function as above with <strong>@lru_cache</strong> with a maximum cache size of 128.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>

<span class="o">@</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="s">"""Calculate nth Fibonacci number - FAST!"""</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Computing fib(</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">)"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>If we call the <strong>lru_cache</strong> decorated fibonacci function now, as <code class="language-plaintext highlighter-rouge">result = fibonacci(10)</code>, below would happen</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Computing</span> <span class="n">fib</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>You would notice a significant fall of the number of actual function invocations in above, since for all the following duplicate function invocations, the results are directly taken from the LRU cache saving an aweful lot of time and energy! Still not impressed? Let’s do a timing comparison for the above function.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>

<span class="c1"># Without cache
</span><span class="k">def</span> <span class="nf">fib_slow</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">fib_slow</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib_slow</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># With LRU cache
</span><span class="o">@</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fib_fast</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">fib_fast</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib_fast</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Test with n=45
</span><span class="k">print</span><span class="p">(</span><span class="s">"Without cache:"</span><span class="p">)</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">fib_slow</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s">, Time: </span><span class="si">{</span><span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="p">.</span><span class="mi">10</span><span class="n">f</span><span class="si">}</span><span class="s">s"</span><span class="p">)</span>
<span class="c1"># Result: 1134903170, Time: 153.0848743916s
</span>
<span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">With cache:"</span><span class="p">)</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">fib_fast</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s">, Time: </span><span class="si">{</span><span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="p">.</span><span class="mi">10</span><span class="n">f</span><span class="si">}</span><span class="s">s"</span><span class="p">)</span>
<span class="c1"># Result: 1134903170, Time: 0.0000000000s  &lt;-- that was lightening fast!!
</span></code></pre></div></div>

<p>Did you just see the above results I’ve got from my machine? The function without the cache took around 153 seconds for the completion, whereas the same function for the same calculation with <strong>lru_cache</strong> ran instaniously to get the same result!! Isn’t that fantastic?</p>

<p>I hope you could imagine the amount of performance gain we can reap from this awesome function decorator.</p>

<h3 id="basic-usage">Basic Usage</h3>

<p>Given below are some examples of how you could use lru_cache</p>

<pre><code class="language-Python">from functools import lru_cache

# Default: maxsize=128
@lru_cache
def my_function(x):
    return x * 2

# Custom cache size
@lru_cache(maxsize=256)
def bigger_cache(x):
    return x * 2

# Unlimited cache (no eviction)
@lru_cache(maxsize=None)
def unlimited_cache(x):
    return x * 2

# Here the cache size is 100, and the type of parameters considered for caching
# ex: my_typed_cache(3) and my_typed_cache(3.0) would be cached seperately
@lru_cache(maxsize=100, typed=True)
def my_typed_cache(x):
    return x * 2
</code></pre>

<h3 id="cache-statistics">Cache statistics</h3>

<p>As every cache <em>lru_cache</em> also has statistics associated with it to represent,</p>
<ul>
  <li><strong>hits</strong>: Times results were returned from cache</li>
  <li><strong>misses</strong>: Times function had to do the computations(real function invocations)</li>
  <li><strong>maxsize</strong>: Maximum size of the cache</li>
  <li><strong>currsize</strong>: Current number of cached items</li>
</ul>

<p>Lets have a look at the below example</p>

<pre><code class="language-Python">from functools import lru_cache

@lru_cache(maxsize=20, typed=True)
def my_super_complex_function(a, b):
    print(f"my_super_complex_function was called! a={a}, b={b}")
    return a+b
</code></pre>

<p>Now lets use call this function a couple of times</p>

<pre><code class="language-Python"># Let's use above function a couple of times
my_super_complex_function(1, 2) # my_super_complex_function was called! a=1, b=2
my_super_complex_function(1.0, 2.0) # my_super_complex_function was called! a=1.0, b=2.0
</code></pre>

<p>If we check the cache statistics now, you may note the current size of the cache to be 2 rather than 1, because this is a typed cache causing it to treat (1, 2) and (1.0, 2.0) as different parameters. In addition both the above calls are cache misses(misses=2), and hence hits=0</p>
<pre><code class="language-Python">print(my_super_complex_function.cache_info()) # CacheInfo(hits=0, misses=2, maxsize=20, currsize=2) 
</code></pre>

<p>Now if we want to hit the cache, we need to pass the parameters equal to something what we have provided before.</p>
<pre><code class="language-Python">res = my_super_complex_function(1.0, 2.0) # Here you would not see the print statement from the my_super_complex_function
print(f"The result is {res}") # The result is 3.0
</code></pre>

<p>If we check the cache statistics now, you would see it has one hit and thats where we have taken the above result.</p>
<pre><code class="language-Python">print(my_super_complex_function.cache_info()) # CacheInfo(hits=1, misses=2, maxsize=20, currsize=2)
</code></pre>

<h3 id="clearing-the-cache">Clearing the Cache</h3>

<p>Its really easy to clear the cache. Example</p>

<pre><code class="language-Python">my_super_complex_function.clear()
print(my_super_complex_function.cache_info()) # 
</code></pre>

<h3 id="when-to-use-lru_cache">When to use lru_cache</h3>

<p>lru_cache is a perfect candidate for following problems</p>

<p>1- Recursive functions with overlapping subproblems ex:-</p>
<ul>
  <li>In the above examples, the problem of Fibonacci(n) is split into Fibonacci(n-1) and Fibonacci(n-2)</li>
  <li><a href="https://en.wikipedia.org/wiki/Factorial">Factoral numbers</a>, ex:- factorial(5) = 5 * factorial(4)
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle">Pascal triangle</a>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">pascal_triangle</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">col</span> <span class="o">==</span> <span class="n">row</span><span class="p">:</span>
      <span class="k">return</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">pascal_triangle</span><span class="p">(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">pascal_triangle</span><span class="p">(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>2- API calls or Database queries requesting the same static data</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>

<span class="o">@</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fetch_weather</span><span class="p">(</span><span class="n">city</span><span class="p">):</span>
    <span class="s">"""Cache weather data for 100 cities"""</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s">"https://api.weather.com/</span><span class="si">{</span><span class="n">city</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span><span class="p">.</span><span class="n">json</span><span class="p">()</span>

<span class="c1"># First call hits API
</span><span class="n">weather</span> <span class="o">=</span> <span class="n">fetch_weather</span><span class="p">(</span><span class="s">"London"</span><span class="p">)</span>  <span class="c1"># API call
</span>
<span class="c1"># Subsequent calls use cache
</span><span class="n">weather</span> <span class="o">=</span> <span class="n">fetch_weather</span><span class="p">(</span><span class="s">"London"</span><span class="p">)</span>  <span class="c1"># From cache!
</span></code></pre></div></div>

<p>3- Mathamatical functions to to deterministic calculations</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>

<span class="o">@</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="s">"""Check if number is prime"""</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="c1"># Filter prime numbers from a list
</span><span class="n">numbers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
<span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">numbers</span> <span class="k">if</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="c1"># Each is_prime call is cached
</span></code></pre></div></div>

<p>4- Computations with python’s property members. 
Property() is python’s built in function to enhance encapsulation and better control of accessing class attributes. To read more on that I’ve found <a href="https://www.geeksforgeeks.org/python/python-property-function/">this</a> to be useful.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DataProcessor</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
    
    <span class="o">@</span><span class="nb">property</span>
    <span class="o">@</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Expensive computation cached as property"""</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Computing total..."</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>

<span class="n">processor</span> <span class="o">=</span> <span class="n">DataProcessor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">processor</span><span class="p">.</span><span class="n">total</span><span class="p">)</span>  <span class="c1"># Computing total... 15
</span><span class="k">print</span><span class="p">(</span><span class="n">processor</span><span class="p">.</span><span class="n">total</span><span class="p">)</span>  <span class="c1"># 15 (from cache)
</span></code></pre></div></div>

<h3 id="when-not-to-use-lru_cache">When not to use lru_cache?</h3>

<p>The knowledge about when not to use lru_cache is paramount to properly use this function in applications without causing hideous bugs. Given below are some examples.</p>

<p>1- When the arguements are Unhashable.
lru_cache requires the funtion’s input parameters to be hashable and it would give errors otherwise. 
Examples for hashable data types are tuples, strings, numbers(int, float), bool, frozensets, NoneType
Examples for unhashable data types are dict, list, set, bytearray.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">lru_cache</span>
<span class="k">def</span> <span class="nf">process_data</span><span class="p">(</span><span class="n">data_dict</span><span class="p">):</span>  <span class="c1"># This Won't work and would give Error: unhashable type: 'dict'
</span>    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">data_dict</span><span class="p">.</span><span class="n">values</span><span class="p">())</span>
</code></pre></div></div>
<p>To read more about this h, I’ve found <a href="https://www.pythonmorsels.com/what-are-hashable-objects/">this</a> article to be useful.</p>

<p>2- When functions have side effects.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">lru_cache</span>  <span class="c1"># This will be a Bad idea!
</span><span class="k">def</span> <span class="nf">send_email</span><span class="p">(</span><span class="n">to_address</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="c1"># Side effect: sends actual email
</span>    <span class="n">email_service</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">to_address</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>

<span class="c1"># If called twice, only first call sends email!
</span><span class="n">send_email</span><span class="p">(</span><span class="s">"user@example.com"</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">)</span>  <span class="c1"># Sends email
</span><span class="n">send_email</span><span class="p">(</span><span class="s">"user@example.com"</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">)</span>  <span class="c1"># Does nothing! (cached)
</span></code></pre></div></div>

<p>3- Access time sensitive data.
If your function include any time sensitive information to be associated to the result, do not use lru_cache as it will return cached results instead.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>

<span class="o">@</span><span class="n">lru_cache</span>  <span class="c1"># Returns stale data!
</span><span class="k">def</span> <span class="nf">get_current_time</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">get_current_time</span><span class="p">())</span>  <span class="c1"># 1234567890.123
</span><span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">get_current_time</span><span class="p">())</span>  <span class="c1"># 1234567890.123 (same! wrong!)
</span></code></pre></div></div>

<p>4- Functions with large return values
Since results from the function are cached in memory, do not use if the function returns large values consuming a lot of memory.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>  <span class="c1"># This could consume GB of RAM!
</span><span class="k">def</span> <span class="nf">load_large_image</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="c1"># Returns 10MB image
</span>    <span class="k">return</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">).</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># With 1000 cached images = 10GB of memory!
</span></code></pre></div></div>

</article>


				</div>
			</div>
			
			<!-- Sidebar -->
<div id="sidebar">
  <div class="inner">

    <!-- Search -->
    <!-- <section id="search" class="alt">
      <form method="get" action="/search/">
        <input type="text" name="q" placeholder="Search" />
      </form>
    </section> -->

    <!-- Menu -->
    <nav id="menu">
      <header class="major">
        <h2>Menu</h2>
      </header>
      <ul>
        <li><a href="/">Homepage</a></li>
        <li><a href="/education/">Education</a></li>
        <li><a href="/workexperience/">Work Experience</a></li>
        <li><a href="/blog/">Blog</a></li>
        <!-- <li>
          <span class="opener">More</span>
          <ul>
            <li><a href="#">Lorem Dolor</a></li>
            <li><a href="#">Ipsum Adipiscing</a></li>
          </ul>
        </li> -->
      </ul>
    </nav>

    <!-- Recent posts -->
    <section>
      <header class="major">
        <h2>Recent posts</h2>
      </header>
      <div class="mini-posts">
        
        <article>
          <a href="/blog/lru_cache/" class="image">
            <img src="/images/lru_cache5.jpg" alt="" />
          </a>
          <p>What is Python's lru_cache and when to use it?</p>
        </article>
        
      </div>
      <ul class="actions">
        <li><a href="/blog/" class="button">More</a></li>
      </ul>
    </section>

    <!-- Get in touch -->
    <section>
      <header class="major">
        <h2>Get in touch</h2>
      </header>
      <p>
        Software Engineer · UK<br />
        Writing about Software Development, Data Science, AI, ML, Agentic AI.
      </p>
      <ul class="contact">
        <li class="icon solid fa-envelope">
          <a href="jap.waruna@gmail.com">jap.waruna@gmail.com</a>
        </li>
        <li class="icon solid fa-home">      
          United Kingdom
        </li>
      </ul>
    </section>

    <!-- Footer -->
    <footer id="footer">
      <p class="copyright">
        &copy; 2026 Waruna Wickramasingha.
        Design: <a href="https://html5up.net">HTML5 UP</a>.
      </p>
    </footer>
  </div>
</div>


		</div>

		<script src="/assets/js/jquery.min.js"></script>
		<script src="/assets/js/browser.min.js"></script>
		<script src="/assets/js/breakpoints.min.js"></script>
		<script src="/assets/js/util.js"></script>
		<script src="/assets/js/main.js"></script>
	</body>
</html>